# React 조건문

JSX안에서는 if문 x 삼항연산자나 && 사용하자. if문 사용할수는 있지만 복잡함..

```js
renderAverage = () => {
    const {result} = this.state;
    return result.length === 0
      ? null
      : <>
        <div>평균 시간: {result.reduce((a, c) => a + c) / result.length}ms</div>
        <button onClick={this.onReset}>리셋</button>
      </>
  };

  render() {
    const { state, message } = this.state;
    return (
      <>
        <div
          id="screen"
          className={state}
          onClick={this.onClickScreen}
        >
          {message}
        </div>
        {this.renderAverage()}
      </>
    )
  }
```

# setTimeout 넣어 반응속도체크

```js
import React, { Component } from 'react';

class ResponseCheck extends Component {
  state = {
    state: 'waiting',
    message: '클릭해서 시작하세요.',
    result: [], // 반응속도체크하기위한 시간기록
  };

  timeout;
  startTime; // 변수는 바뀌어도 재렌더링 x
  endTime;

  onClickScreen = () => {
    const { state } = this.state; // 구조분해
    if (state === 'waiting') {
      timeout.current = setTimeout(() => {
        this.setState({
          state: 'now', // 초록색으로 바꿔줌
          message: '지금 클릭',
        });
        this.startTime = new Date(); // 초록색으로 바뀐시점 기록
      }, Math.floor(Math.random() * 1000) + 2000); // 2초~3초 랜덤 타이머 설정 2~3초 뒤에 초록색화면으로 바뀜
      this.setState({
        state: 'ready', // 빨간색으로 바꿔줌
        message: '초록색이 되면 클릭하세요.',
      }); // 초록색 클릭시 빨간색화면으로 바뀜
    } else if (state === 'ready') {
      // 성급하게 클릭
      clearTimeout(this.timeout); // 타이머 제거 해야 버그안생김 (안하면 몇초뒤에 초록색으로 바껴버림)
      this.setState({
        state: 'waiting',
        message: '너무 성급하시군요! 초록색이 된 후에 클릭하세요.',
      });
    } else if (state === 'now') {
      // 반응속도 체크
      endTime.current = new Date(); // 초록색 클릭한 시점 기록
      this.setState((prevState) => {
        // 이전 state이용해 미래 state 표현해서 함수사용
        return {
          state: 'waiting',
          message: '클릭해서 시작하세요.',
          result: [...prevState.result, this.endTime, this.startTime],
        };
      });
    }
  };

  onReset = () => {
    this.setState({
      result: [],
    });
  };

  renderAverage = () => {
    const { result } = this.state;
    return result.length === 0 ? null : ( // 기록이없으면 화면 표시 안함
      <>
        <div>평균 시간: {result.reduce((a, c) => a + c) / result.length}ms</div>
        <button onClick={this.onReset}>리셋</button>
      </>
    );
  };

  render() {
    const { state, message } = this.state;
    return (
      <>
        <div id='screen' className={state} onClick={this.onClickScreen}>
          {message}
        </div>
        {this.renderAverage()}
        {/* renderAverage함수는 호출해야 실행됨 */}
      </>
    );
  }
}

export default ResponseCheck;
```

# 성능 체크와 Q&A

# 반응속도체크 Hooks로 전환하기

- startTime, endTime을 ref를 사용하지 않고, 바닐라 자바스크립트처럼 let으로 선언해도 작동하는 것 같은데 리액트에선 이렇게 사용하면 안되나요?

  - 리렌더링때마다 초기화됩니다

- 그런데 let 선언문을, 함수 안에가 아니라 함수 바깥에 선언하면 리렌더링돼도 초기화 안되는거 아닌가요? 직접해보니 역시 값은 유지되고 있네요.. 방법은 이렇게 하는게 훨씬 편할텐데, 실무에선 useRef 를 사용하는 이유가 있을까요???

  - 컴포넌트를 여러번 재사용할 때 문제가 됩니다. 컴포넌트마다 각자의 값(useRef)를 갖고 있어야하는데 let을 외부에 선언한 걸 사용하면 모든 컴포넌트가 그 let 값으로 통일되어 버립니다.

## useRef의 두번째 용도

useRef 는 값이 바뀌기는 하지만 화면에는 영향을 미치고 싶지 않을때 ref 사용!

즉, 화면을 바꾸고싶진않은데 값이 바뀌는것들은 useRef에 담아서 사용하자.

# return 내부에 for과 if 쓰기

```js
{
  (() => {
    if (result.length === 0) {
      return null;
    } else {
      return (
        <>
          <div>
            평균 시간: {result.reduce((a, c) => a + c) / result.length}ms
          </div>
          <button onClick={onReset}>리셋</button>
        </>
      );
    }
  })();
}
```

if문을 함수안에넣고 함수를 즉시실행하면 된다.

```js
{
  (() => {
    const array = [];
    for (let i = 0; i < tries.length; i++) {
      array.push(<Try key={`${i + 1}차 시도 : ${v.try}`} tryInfo={v} />);
    }
    return array;
  })();
}
```

for문을 함수안에넣고 함수를 즉시실행하면 된다.

이렇게 할빠에는 함수로 빼는게 났다. 제일 좋은방법은 컴포넌트로 분리하는것이다.

```js
return [
  <div key="사과">사과</div>
  <div key="배">배</div>
  <div key="감">감</div>
  <div key="귤">귤</div>
  <div key="밤">밤</div>
]
```
