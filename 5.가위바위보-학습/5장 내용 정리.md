# 1. 리액트 라이프사이클 소개 & 2. setInterval과 라이프사이클 연동하기

- 클래스의 경우 -> constructor -> render -> ref -> componentDidMount
  -> (setState/props 바뀔때) -> shouldComponentUpdate(true) -> render -> componentDidUpdate -> 부모가 나를 없앴을 때 -> componentWillUnmount -> 소멸

```js
componentDidMount() {
    // 컴포넌트가 첫 렌더링된 후, 여기에 비동기 요청을 많이 해요
    this.interval = setInterval(this.changeHand, 100);
  }

  shouldComponentUpdate(nextProps, nextState, nextContext) {
    return true; // 리렌더링!
  }

  componentDidUpdate() {
    // 리렌더링 후
  }

  componentWillUnmount() {
    // 컴포넌트가 제거되기 직전, 비동기 요청 정리를 많이 해요
    clearInterval(this.interval);
  }
```

- componentDidMount() {}

  - 컴포넌트가 성공적으로 렌더링을 완료하는 순간 실행되는 리액트 라이프사이클 메서드

  - 리렌더링 될때는 실행되지 않는다.

  - 해당 부분에 비동기 요청을 많이 정리한다.

  - setInterval 함수를 해당 부분에 넣게 된다.

  - 이번 섹션에서는 가위바위보 이미지를 적절하게 잘라서 화면에 보여주기 위한 과정으로 활용.

  - **클로저문제 발생**

    - 비동기 setTimeout 함수에서 바깥에 있는 변수 imgCoord를 참조할 때는 이미 고정된 값이 되어 있기 때문에, 클로저 문제가 발생한다. 그래서 바깥에 변수를 선언해서 가져오는게 아니라 비동기 함수 내부에서 변수를 선언하고 가져올 수 있도록 해야한다.

- componentDidUpdate() {}

  - 컴포넌트가 리렌더링 될때 실행시킬 함수

- componentWillUnmount() {}

  - 컴포넌트가 제거되기 직전에 실행될 함수

  - 해당 부분에 비동기 요청 정리 많이 진행한다.

  - 해당부분에서 clearInterval을 해준다.

# 3. 가위바위보 게임 만들기

- RSPClass.jsx 참고

- onClickBtn 함수에서 가위바위보 중 하나의 버튼을 눌렀을 때 setInterval을 잠시 멈춰서 현재 컴퓨터가 낸 손을 확인하고 이에 대해서 이겼는지, 비겼는지, 졌는지를 확인할 수 있는 로직 작성.

# 4. 고차 함수와 Q&A

- (choice) => () => 이렇게 화살표 함수를 한번 더 작성하면 아래에서 onClick 이벤트에서 () => 이 부분을 제거해도 동작할 수 있게 해주는데, 이를 고차 함수라고 한다.

- setInterval을 매우짧게 하면 setState와 render까지의 시간에서 엇갈리는 경우가 없을까?

  - 너무 짧게 시간을 세팅하면 너무 자주 렌더링이 되어서 화면이 감당하는 것처럼 문제가 생기는 것처럼 보이지만, 결국 setState는 Queue로 쌓여서 엇갈리는 경우는 없다. 단, setState를 연달아 쓰는 경우에는 해당 setState를 하나로 묶어서 처리하게 된다.

# 5. Hooks와 useEffect

```js
useEffect(() => {
  // componentDidMount, componentDidUpdate 역할(1대1 대응은 아님)
  console.log('다시 실행');
  interval.current = setInterval(changeHand, 100);
  return () => {
    // componentWillUnmount 역할
    console.log('종료');
    clearInterval(interval.current);
  };
}, [imgCoord]);
```

# 6. 클래스와 function 컴포넌트 라이프사이클 비교

```js
//                        result, imgCoord, score
// componentDidMount
// componentDidUpdate
// componentWillUnmount

// componentDidMount() {
//   this.setState({
//     imgCoord: 3,
//     score: 1,
//     result: 2,
//   })
// }

// useEffect(() => {
//   setImgCoord();
//   setScore();
// }, [imgCoord, score]);

// useEffect(() => {
//   setResult();
// }, [result]);
```

componentDidMount, componentDidUpdate, componentWillUnmount는 한방에

useEffect는 따로따로!

# 커스텀 훅으로 우아하게 interval하기

```js
import { useRef, useEffect } from 'react';

// const [isRunning, setRunning] = useState(true);
// useInterval(() => {
//  console.log('hello');
// }, isRunning ? 1000 : null);

// 커스텀 훅? 훅들을 우리가 직접만들수 있음
// 보통 어떤 특정한 훅 2개이상이 반복된다 할때 커스텀 훅을 만듬
// useRef와 useEffect가 하나의 interval 역할을 해서 하나의 커스텀 훅으로 만든다.

// 1초 뒤에 가위
// 1.1초 뒤에 changeHand
// 2초 뒤에 바위
// 2.1초 뒤에 changeHand
// 3초 뒤에 보
// 3.1초 뒤에 changeHand
function useInterval(callback, delay) {
  const savedCallback = useRef(); // useRef를 쓰면 최신 callback을 참조가능

  useEffect(() => {
    savedCallback.current = callback; // 실행할코드를 ref에 저장
  });

  useEffect(() => {
    function tick() {
      savedCallback.current(); // 최신 callback을 tick함수에 담아둠
    } //

    if (delay !== null) {
      let id = setInterval(tick, delay); // delay가 null이 아닐때 실행
      return () => clearInterval(id); // delay가 null이 되면 clearInterval
    }
  }, [delay]);

  return savedCallback.current;
}

export default useInterval;
```
