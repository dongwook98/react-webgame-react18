# import vs require

- require은 노드의 모듈시스템이다.

- es2015 module 시스템 => import, export

- 노드 module 시스템 => require, module.exports

```js
const React = require('react');
import React from 'react';

export const hello = 'hello'; // import { hello } // 여러번 사용 가능

export default hello; // import hello // 한번만 사용 가능
```

- import는 바벨이 require로 변환해서 쓸 수 있게 도와준다. node에서는 require를 사용해야 한다(Webpack에서 사용할때).

- exports되는 게 객체나 배열이면 구조 분해할 수 있다.

```js
export const hello = 'hello'; // import { hello }

export const bye = 'hello'; // import { hello, bye }

export default NumberBaseball; // import NumberBaseball;
```

- default 키워드는 파일 당 한번만 사용가능.

- export default 와 module.exports는 호환된다. 원래는 다른것!!

```js
const React = require('react');

exports.hello = 'hello';

module.exports = NumberBaseball;
```

노드 모듈 시스템(Common JS)에서

```js
module.exports = { hello: 'a' };

exports.hello = 'a'는 같다.
```

<br>
<br>
<br>

# 리액트에서는 import export 사용 가능! , 노드에서는 require, module.exports만 사용가능!

노드로 웹팩을 돌리기 때문에 노드에서는 노드 모듈 시스템만 지원을 하기 때문에 webpack.config.js 에서는 require, module.exports 만 써야한다.

또한 원래 client.jsx에서도 노드 모듈 시스템을 써야하지만 웹팩에 들어있는 바벨이 es5 모듈 시스템을 쓸 수 있게 해주기 때문에 import, export 를 사용할 수 있다.

<br>
<br>
<br>

# 리액트 반복문(map)

```js
<li>사과</li>
<li>바나나</li>
<li>포도</li>
<li>귤</li>
<li>감</li>
<li>배</li>
<li>밤</li>
```

위 코드를 map으로 축약가능

```js
<ul>
  {['사과', '바나나', '포도', '귤', '감', '배', '밤'].map((v) => {
    return <li>{v}</li>;
  })}
</ul>
```

<br>
<br>
<br>

# 리액트 반복문(key)

```js
<li><b>사과</b> - 맛있다.</li>
<li><b>바나나</b> - 맛없다.</li>
<li><b>포도</b> - 시다.</li>
<li><b>귤</b> - 떫다.</li>
<li><b>감</b> - 쓰다.</li>
<li><b>배</b> - 달다.</li>
<li><b>밤</b> - 몰라.</li>
```

위 코드는 바뀌는 부분이 2개씩 있음.

```js
<ul>
  {[
    ['사과', '맛있다'],
    ['바나나', '맛없다'],
    ['포도', '시다'],
    ['귤', '떫다'],
    ['감', '쓰다'],
    ['배', '달다'],
    ['밤', '몰라'],
  ].map((v) => {
    return (
      <li>
        <b>{v[0]}</b> - {v[1]}
      </li>
    );
  })}
</ul>
```

이차원 배열로 2가지가 바뀔때 반복문 표현

```js
<ul>
  {[
    { fruit: '사과', taste: '맛있다'},
    { fruit: '바나나', taste: '맛없다'},
    { fruit: '포도', taste: '시다'},
    { fruit: '귤', taste: '떫다'},
    { fruit: '감', taste: '쓰다'},
    { fruit: '배', taste: '달다'},
    { fruit: '사과', taste: '맛없다'},
  ].map((v, i) =>  (
      <li key={v.fruit + v.taste}><b>{v.fruit}</b> - {v.taste}</li>
    );
  )}
</ul>
```

보통 객체로 많이 표현함!

key에는 고유한값을 써줘야함!

리액트가 key를 보고 같은 컴포넌트인지 아닌지 판단함

key에다가 i를 쓰지마라. 나중에 성능최적화할때 문제가 된다.

요소가 추가만 되는 배열인 경우 i를 써도 되긴하다. (삭제될때는 x)

<br>
<br>
<br>

# 컴포넌트 분리와 props

```js
class Try extends Component {
  render() {
    return (
      <ul>
        {this.fruit.map((v, i) => {
          return (
            <li key={this.props.value.fruit + this.props.value.state}>
              <b>
                {this.props.index} : {this.props.value.fruit}
              </b>{' '}
              - {this.props.value.taste}
              <div>컨텐츠1</div>
              <div>컨텐츠2</div>
              <div>컨텐츠3</div>
              <div>컨텐츠4</div>
              <div>컨텐츠5</div>
            </li> // 코드 압축! (가독성 , 재사용성, 성능최적화)
          );
        })}
      </ul>
    );
  }
}
```

위 map return 부분이 너무 길어질수도 있음 길어진 부분을 다른 파일로 빼보자.

```js
import React, { Component } from 'react';

class Try extends Component {
  render() {
    return (
      <li key={this.props.value.fruit + this.props.value.state}>
        <b>
          {this.props.index} : {this.props.value.fruit}
        </b>{' '}
        - {this.props.value.taste}
        <div>컨텐츠1</div>
        <div>컨텐츠2</div>
        <div>컨텐츠3</div>
        <div>컨텐츠4</div>
        <div>컨텐츠5</div>
      </li>
    );
  }
}

export default Try;
```

export default 해야 다른 파일에서 쓸 수 있음~

props 받아올때는 this.props.~~~

```js
import Try from './Try';

...

render() {
    return (
      <>
        <h1>{this.state.result}</h1>
        <form onSubmit={this.onSubmitForm}>
          <input maxLength={4} value={this.state.value} onChange={this.onChangeInput}/>
        </form>
        <div>시도: {this.state.tries.length}</div>
        <ul>
          {this.fruit.map((v, i) => {
            return (
              <Try key={v.fruit + v.taste} value={v} index={i}/> // 코드 압축! (가독성 , 재사용성, 성능최적화)
            )
          })}
        </ul>
      </>
    )
  }
```

컴포넌트를 불러올땐 상단에 import~

위 코드처럼 컴포넌트를 분리하면 된다. 컴포넌트를 분리하면 가독성 up, 재사용성 up, 성능 최적화가능

이때 Try 컴포넌트에 v와 i를 props로 전달해줘야한다. 전달을 안하면 Try 컴포넌트에서 v와 i를 쓰지 못한다.

입문자는 한 컴포넌트에 다 적고 분리하고 싶은곳을 분리하자. (탑 다운 방식)

능숙해지면 저절로 바텀 업 방식으로 짤 것이다.

props가 생기면서 부모 자식관계가 생긴다. NumberBaseball가 Try의 부모 컴포넌트이다.

부모 -> 자식 방향으로 props를 전달가능

<br>
<br>
<br>

# props의 문제점

리액트의 대부분의 문제는 props에서 발생한다.

왜냐하면 부모 자식 관계만 있는게 아니라 자식이 또 자식을 가지면 부모 자식 손자 관계가 생긴다.

만약에 부모에서 손자에게 데이터를 보내주는 경우도 있는데 , 이런 경우 점점 더 깊어지면 큰 문제가 된다.. 이때 쓰이는게 리덕스 아니면 ContextAPI 이다.

<br>
<br>
<br>

# 주석과 메서드 바인딩

리액트에서 주석은 {/\* \*/} 사용!

클래스 컴포넌트에서 메서드 바인딩은 화살표 함수사용하자.

화살표 함수를 사용하지 않으면 this바인딩이 안되기 때문임!

```js
class NumberBaseball extends Component {
  constructor(props) {
    super(props);
    this.state = {
      result: '',
      value: '',
      answer: getNumbers(),
      tries: [],
    };
    this.onSubmitForm = this.onSubmitForm.bind(this);
    this.onChangeInput = this.onChangeInput.bind(this);
  }
}
```

function 키워드로 메서드 등록하고 싶다면 위 코드를 적어야 한다!

<br>
<br>
<br>

# useState lazy init 용법

```js
const [answer, setAnswer] = useState(getNumbers);
```

lazy init

함수를 넣으면 함수의 리턴값이 answer에 들어간다. 그리고 그 함수는 다시 실행되지않는다.

```js
const [answer, setAnswer] = useState(getNumbers());
```

이렇게 해도 문제는 없다. 왜냐하면 useState가 알아서 getNumbers의 첫번째 리턴값을 answer에 넣어주고 리렌더링될때는 getNumbers가 다시 실행은 되지만, 두번째 이상부터의 리턴값은 알아서 무시해준다.(초깃값 자리기 때문에) 다만, 쓸데없이 getNumbers 함수가 실행되는게 문제이다. 만약 getNumbers 함수가 엄청나게 복잡하고 오래걸리는 연산이라면 매우 비효율적일 것이다. 리렌더링 할 때마다 복잡하고 오래걸리는 연산이 계속 실행되기 떄문이다.

<br>
<br>
<br>

# 리액트 성능 향상

state가 변경될때 마다 바뀌지않는 컴포넌트도 다 렌더링 되는경우 문제가 된다.

```js
shouldComponentUpdate(nextProps, nextState, nextContext) {
    if (this.state.counter !== nextState.counter) {
      // 현재 카운터와 미래 카운터가 다르면
      return true; // 렌더링
    }
    return false; // 렌더링 x
}
```

이렇게 적어주면 문제 해결! shouldComponentUpdate를 사용하면 어떨때 렌더링을 다시할지 조종 할 수 있다.

<br>
<br>
<br>

# 억울한 자식 리렌더링 막기(PureComponent와 memo)

```js
return (
  <>
    <h1>{result}</h1>
    <form onSubmit={onSubmitForm}>
      <input
        ref={inputEl}
        maxLength={4}
        value={value}
        onChange={onChangeInput}
      />
      <button>입력!</button>
    </form>
    <div>시도: {tries.length}</div>
    <ul>
      {tries.map((v, i) => (
        <Try key={`${i + 1}차 시도 : ${v.try}`} tryInfo={v} />
      ))}
    </ul>
  </>
);
```

컴포넌트는 props가 바뀌거나 state가 바뀐다. 더나아가서 부모 컴포넌트가 리렌더링 되면 자식 컴포넌트도 반드시 리렌더링 된다.

위 코드에서 Try 컴포넌트는 억울할 것이다. 왜냐하면 input 부분에서 글자를 입력하면 value 때문에 리렌더링이 되는것 일텐데 부모가 리렌더링 됬다고 자식까지 리렌더링 되기 때문이다. 이걸 해결 해줄수 있는게 PureComponent이다.

```js
import React, { PureComponent } from 'react';

class Try extends PureComponent {
  render() {
    const { tryInfo } = this.props;
    return (
      <li>
        <div>{tryInfo.try}</div>
        <div>{tryInfo.result}</div>
      </li>
    );
  }
}

export default Try;
```

PureComponent의 기능은 state가 달라졌을때만 리렌더링 되게 하는 기능 외에도 props가 달라졌을때만 리렌더링 되게해주는 기능도 제공한다.

함수 컴포넌트에서는 PureComponent 대신에 memo를 사용한다.

```js
import React, { memo } from 'react';

const Try = memo(({ tryInfo }) => {
  return (
    <li>
      <div>{tryInfo.try}</div>
      <div>{tryInfo.result}</div>
    </li>
  );
});
Try.displayName = 'Try'; // memo를 해주면 리액트 데브툴에서 컴포넌트 이름이 변경되서 다시 지정해줘야한다.

export default Try;
```

memo는 부모 컴포넌트가 리렌더링 됬을 때 자식 컴포넌트가 리렌더링 되는것만 막아준다.

<br>

Component, PureComponent 뭐가 더 좋은가?

PureComponent가 간편하긴 하지만, Component 구조가 복잡해질 경우 적용이 잘 안될수도 있다.

Component에서는 shouldComponentUpdate를 이용해서 어떨때 렌더링 되게할 지 자유롭게 지정해서 쓸 수 있다.

# React.createRef

```js
import React, { Component, createRef } from 'react';

inputRef = createRef();

...

render() {
  const { result, value, tries } = this.state;
  return (
    <>
      <h1>{result}</h1>
      <form onSubmit={this.onSubmitForm}>
        <input
          ref={this.inputRef}
          maxLength={4}
          value={value}
          onChange={this.onChangeInput}
        />
      </form>
      <div>시도: {tries.length}</div>
      <ul>
        {tries.map((v, i) => {
          return (
            <Try key={`${i + 1}차 시도 :`} tryInfo={v} index={i} /> // 코드 압축! (가독성 , 재사용성, 성능최적화)
          );
        })}
      </ul>
    </>
  );
}
```

와 같이 간단하게 할 수 있다.

기존의 ref 방식과의 차이점은 ref 방식은 함수기 때문에 함수안에 다른 코드(정밀한 동작)를 넣을수 있다.

# props와 state 연결하기

부모로 받은 props는 자식이 바꾸면 안된다.

그러나 props를 바꿔야할 경우가 있다. 그럴때 props를 state에 넣어준다.

```js
import React, { memo, useState } from 'react';

const Try = memo(({ tryInfo }) => {
  // tryInfo.result = 'hello' // 자식컴포넌트에서 props 수정 ❌
  // 자식이 props를 바꿔버리면 부모가 뜻하지 않게 바껴버림..
  // 진짜 바꿔야하면 props를 state로 만든다음에 state를 바꾼다.
  const [result, setResult] = useState(tryInfo.result);

  const onClick = () => {
    setResult('1');
  };
  return (
    <li>
      <div>{tryInfo.try}</div>
      <div onClick={onClick}>{result}</div>
    </li>
  );
});
Try.displayName = 'Try';

export default Try;
```

클래스 컴포넌트에서 props 를 state에 넣기

```js
import React, { PureComponent } from 'react';

class Try extends PureComponent {
  // constructor(props) {
  //   super(props);
  //    다른 동작
  //   const filtered = this.props.filter(() => {});
  //   this.state = {
  //     result: filtered,
  //     try: this.props.try,
  //   };
  // }
  state = {
    result: this.props.result,
    try: this.props.try,
  };

  render() {
    const { tryInfo } = this.props;
    return (
      <li>
        <div>{tryInfo.try}</div>
        <div>{tryInfo.result}</div>
      </li>
    );
  }
}

export default Try;
```

constructor을 써야할 경우 : 미세한 컨트롤이 필요한 경우!

ref에서도 setState에서도 함수를 넣으면 미세한 컨트롤을 할 수 있다. 위와같은 맥락이다!
