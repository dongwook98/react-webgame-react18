<html>
  <head>
    <meta charset="UTF-8" />
    <title>구구단</title>
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <!-- 결과: <div id="root"><button>Like</button></div> -->
    <script type="text/babel">
      class GuGuDan extends React.Component {
        // constructor 생략가능
        state = {
          first: Math.ceil(Math.random() * 9),
          second: Math.ceil(Math.random() * 9),
          value: '',
          result: '',
        };

        // 직접 만든 함수는 화살표함수 써야한다. this가 달라져버림.
        onSubmit = (e) => {
          e.preventDefault();
          // 구구단 로직
          if (
            parseInt(this.state.value) ===
            this.state.first * this.state.second
          ) {
            // 정답
            // 우리가 바뀔 부분을 정확히 컨트롤 하는거다.
            this.setState((prevState) => {
              // 아래 4개는 미래 상태값이다. 현재 state와 미래 state를 같이 쓰지 말고 setState안에다가 새로운 state를 리턴하는 함수를 쓰자.
              return {
                result: prevState.value + ' 정답!',
                first: Math.ceil(Math.random() * 9),
                second: Math.ceil(Math.random() * 9),
                value: '',
              };
            });
            this.input.focus();

            // this.setState((prevState) => {
            //   value: prevState.value + 1
            // })
            // this.setState((prevState) => {
            //   value: prevState.value + 1
            // })
            // this.setState((prevState) => {
            //   value: prevState.value + 1
            // })
            // 새로운 value가 기존 value + 3이 될꺼라고 예상하지만 +1 이 될 수도 있다. why?
            // setState()는 비동기로 동작하기 때문이다.
          } else {
            // 오답
            this.setState({
              result: '땡',
              value: '',
            });
            this.input.focus();
          }
        };

        onChange = (e) => {
          this.setState({ value: e.target.value });
        };

        input;

        onRefInput = (c) => {
          this.input = c;
        };
        // onSubmit, onChange, onRefInput 이렇게 함수를 바깥으로 빼야지 더 좋다. 왜냐하면 state가 변경될때 render 함수가 다시 실행되는데,
        // 안에 있으면 setState 될 때마다 우리가 만든 함수가 계속 새로 생기게 된다.

        // 컨텐츠
        render() {
          // setState를 할때는 render 함수가 다시 실행된다.
          // 만약 이 줄에 10초 걸리는 작업 long()이 있다면 state가 변경될 때마다 10초이상이 걸리게 되서 서비스가 마비될것이다.
          console.log('렌더링');
          return (
            // 필요없는 div는 <> </>
            <React.Fragment>
              <div>
                {this.state.first} 곱하기 {this.state.second}는?
              </div>
              <form onSubmit={this.onSubmit}>
                <input
                  ref={this.onRefInput}
                  type='number'
                  value={this.state.value}
                  onChange={this.onChange}
                  // input 창도 변하니까 state로 등록 -> setState로 변경해줘야함 안그러면 입력이 안된다.
                />
                <button type='submit'>입력!</button>
              </form>
              <div>{this.state.result}</div>
            </React.Fragment>
          );
        }
      }
    </script>
    <script type="text/babel">
      ReactDOM.createRoot(document.querySelector('#root')).render(
        <React.Fragment>
          <h3>
            아래 구구단 3개는 같은 컴포넌트지만 각각 다른 state를 가진다.
            재사용성 굳..
          </h3>
          <GuGuDan />
          <GuGuDan />
          <GuGuDan />
        </React.Fragment>
      );
    </script>
  </body>
</html>

<!-- 바뀌는것들은 state로 등록해두어야한다. 

  JSX랑 자바스크립트랑 섞어쓰지 마라.
  class의 메서드로 등록해서 사용해라.
  현재 state와 미래 state를 같이 쓰지 말고 setState안에다가 새로운 state를 리턴하는 함수를 쓰자.
  
  리액트는 state를 바꾸면 화면을 저절로 바꿔준다. 
  만약 input을 입력하고 input에 focus를 하고싶다면?
  document.querySelector('input').focus() 를 해도 되지만
  리액트에서는 document 이런거는 거의 안쓴다고 보면 된다.
  리액트안에서는 리액트가 화면을 컨트롤 할 수 있게 해주는게 좋다. 
  리액트가 화면을 만들어준다고 생각하고 우리는 데이터만 바꿔주면 된다.
  그래서 리액트가 제공하는걸 써야한다. 
  DOM에 접근하고 싶을때는 ref를 붙여서 접근하면된다.

  onSubmit, onChange, onRefInput 이렇게 함수를 바깥으로 빼야지 더 좋다. 왜냐하면 state가 변경될때 render 함수가 다시 실행되는데,
  안에 있으면 setState 될 때마다 우리가 만든 함수가 계속 새로 생기게 된다. 
  
-->
